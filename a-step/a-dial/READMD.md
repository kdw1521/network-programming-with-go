# GOAL
```text
서버와 연결 수립
- 간단하게 클라이언트(conn) 서버(listener) 연결을 해본다.
```

---

## 코드 분석
```go
listener, err := net.Listen("tcp", "127.0.0.1:")
	if err != nil {
		t.Fatal(err)
	}
/*
    TCP 프로토콜을 사용하여 로컬 호스트(127.0.0.1)의 임의의 포트에 리스너를 생성. 
    에러가 발생하면 테스트를 실패로 처리하고 종료
*/
```

```go
done := make(chan struct{})
/*
    채널 done을 생성.
    이 채널은 고루틴 사이에서 완료 신호를 전달하는 데 사용.
*/
```

```go
go func() { // 새로운 고루을 시작.
    defer func() { done <- struct{}{} }() // 리스너가 종료될때 done 채널에 신호를 보내기 위해 defer 처리

    for {
        conn, err := listener.Accept() // 리스너가 클라이언트 연결을 수락할때 까지 대기
        if err != nil { // 에러 발생 시 루프 종료
            t.Log(err)
            return
        }

        go func(c net.Conn) { // 수락된 각 연결 대해 다른 고루틴 시작
            defer func() { // 연결이 종료 될때 연결을 닫고 done 채널에 신호를 보냄
                c.Close()
                done <- struct{}{}
            }()

            buf := make([]byte, 1024) // buf를 생성.
            for {
                n, err := c.Read(buf) // 연결로 부터 데이터를 읽음.
                if err != nil {
                    if err != io.EOF { // EOF가 아닐시 에러처리.
                        t.Error(err)
                    }
                    return // EOF 면 종료
                }
                t.Logf("received: %q", buf[:n]) // 모든 로그 출력
            }
        }(conn)
    }
}()
```

```go
conn, err := net.Dial("tcp", listener.Addr().String())
if err != nil {
t.Fatal(err)
}

conn.Close() // 클라이언트가 서버와의 연결 종료
<-done
listener.Close() // 서버 리스너가 새 연결 수락하지 않도록 닫아줌. 현재 연결 중인 클라이언트는 계속 처리되지만 추가 연결은 되지 않음.
<-done
/*
TCP 프로토콜을 사용하여 리스너에 연결.
에러가 발생하면 테스트를 실패로 처리하고 종료.

클라이언트 연결을 닫음.
done 채널에서 신호를 기다림.
리스너를 닫고, 또 한 번 done 채널에서 신호를 기다림.
*/
```

---

## 개인적 고찰 (왜? WHY?)

### 1. 채널을 왜 struct{} 로 했을까?
    1. 메모리 효율성
    
    [메모리 사용량이 0 이다.]
    빈 구조체는 메모리 사용량이 0이다.
    즉, struct{}{}는 메모리를 소비하지 않으므로 매우 효율적이겠다.
    신호 전달용으로는 데이터가 필요 없기 때문에 메모리를 소비하지 않는 빈 구조체가 적합해보인다.

    [경량 신호 전달]
    다른 타입(예: int나 bool)을 사용하면 메모리를 소비하게 된다.
    예를 들어, bool 타입은 1바이트를 사용하지만  빈 구조체는 메모리 사용량이 0이므로 가장 가벼운 방법이겠다.

    
    
    2. 명확한 의도를 전달할수 있다.
    
    [명시적 의도 표현]
    빈 구조체는 "데이터 없이 신호만 전달"하려는 의도를 명확하게 나타낸다.
    코드를 읽는 사람이 빈 구조체를 보면 데이터가 아닌 신호를 전달하려는 의도임을 즉시 이해할 수 있겠다.

    [코드 가독성 향상]
    빈 구조체를 사용하면 코드가 간결해지고 가독성이 향상되는 효과가 있어보인다.
    다른 타입을 사용하면 어떤 데이터를 전달하려는지 고민할 수 있지만, 빈 구조체는 그런 혼란을 줄여줄수 있겠다.

    
    
    3. 타입 안정성
    
    [타입 안정성 유지]
    빈 구조체를 사용하면 특정 데이터 타입에 의존하지 않으므로 타입 안정성이 유지된다.
    이것은 코드의 일관성을 높이고, 타입 관련 오류를 줄이는 데 도움이 되겠다.

    [타입 변환 불필요]
    신호 전달용으로 int, bool 등 다른 타입을 사용할 경우 불필요한 타입 변환이나 값 할당이 필요할 수 있다.
    빈 구조체는 이러한 작업을 필요로 하지않으니 베스트다.\

    
    
    
    4. 성능 최적화
    
    [빠른 동작]
    빈 구조체는 크기가 0이기 때문에 관련 연산(생성, 전달, 비교 등)이 매우 빠르게 수행되곘다. 이것은 성능을 최적화하는 데 베스트.
    
    [경합 최소화]
    고루틴 간의 통신에서 빈 구조체를 사용하면 불필요한 경합을 최소화할 수 있겠다.
    메모리 접근이나 불필요한 데이터 복사가 없기 때문에 성능 저하를 방지할 수 있겠다.

    